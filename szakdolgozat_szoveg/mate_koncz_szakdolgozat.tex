\documentclass[a4paper,12pt]{report}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\def\magyarOptions{defaults=hu-min}
\usepackage[magyar]{babel}
\usepackage{amsthm, amssymb,amsmath,hyperref}
\usepackage{enumerate, graphicx, xcolor}

\usepackage{chngcntr}
\counterwithout{figure}{chapter}
\counterwithout{figure}{section}
\counterwithout{figure}{subsection}
%\usepackage{pgf,tikz,float}
%\usepackage{tikzlings}
%\usepackage{tikzducks}
%\usetikzlibrary{arrows}
\usepackage[nobysame]{amsrefs}
%\usepackage{amsmath}

\usepackage{geometry}
 \geometry{
 a4paper,
 total={160mm,247mm},
 left=25mm,
 top=25mm,
 }


\newtheorem{theo}{tétel}[section]
\newtheorem{defin}[theo]{definíció}
\newtheorem{lemma}[theo]{lemma}
\newtheorem{all}[theo]{állítás}
\newtheorem{kov}[theo]{következmény}

\theoremstyle{definition}
\newtheorem{definition}[theo]{definíció}

\theoremstyle{remark}
\newtheorem{megj}[theo]{megjegyzés}




\date{today}

\linespread{1.3}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}



\begin{document}
\thispagestyle{empty}

\begin{center}
 {\Large A dolgozat formai követelményei}   
\end{center}
 
\vspace{1 cm}

{\bf Ajánlott oldalszám:}
\begin{itemize}
\item BSc szakdolgozat: 20-25 oldal, 
\item MSc diplomamunka: 35-50 oldal
\item Tanárszakos szakdolgozat: 50000-80000 karakter szóközökkel (lásd. TKK szabályzat)
\end{itemize}

\vspace{1 cm}

{\bf Másfeles sorköz, sorkizárt, 12-es betű méret (általában Computer Modern), margók: jobb, bal, lent és fent 2,5 cm} (ahogy ez a template van beállítva, az jó).

\vspace{1 cm}

{\bf Kötelező elemei a dolgozatnak}
\begin{itemize}
    \item Címlap
    \item Tartalmi összefoglaló (kivonat)
    \item Tartalomjegyzék
    \item \textcolor{red}{Érdemi rész}
(Szakterület specifikus fejezeteket tartalmaz, kérjük, konzultáljon a témavezetővel, hogy a példában közzétett kísérletes tudományterületeken használt fejezetekből az Ön dolgozatában melyikre van szükség!)
\item Irodalomjegyzék
\item Nyilatkozat
\end{itemize}
\newpage



\pagenumbering{roman}

%Elso  oldal 
\thispagestyle{empty}

\begin{center}
\vspace*{0.2cm} {\Large\bf Szegedi Tudományegyetem}
\vspace{0.3cm}

{\Large\bf Természettudományi és Informatikai Kar}
\vspace{0.3cm}

{\Large\bf Informatikai Intézet, Szoftverfejlesztés Tanszék}
\vspace{3cm}



{\Large SZAKDOLGOZAT}

\vspace*{1.5cm}

{\LARGE\bf Eseményszervező webalkalmazás konfigurációs lehetőségekkel}

Configurable event organizing web application



\vspace*{4cm}

{\large
\begin{tabular}{c@{\hspace{2cm}}c}
\emph{Készítette:}     &\emph{Témavezető:}\\
\bf{Koncz Máté}  &\bf{Dr. Pengő Edit}\\
Programterveő Informatikus BSc hallgató    & egyetemi docens\\
&
\end{tabular}
}

\vspace*{1,5cm}

{\Large Szeged\\ \vspace{2mm} 2025}
\end{center}

%masodik oldal osszefogalalo
\begin{abstract}
A dolgozat tartalmának rövid (max. 1 oldal) összefoglalása. A következő részekből áll: rövid irodalmi összefoglaló, a dolgozat elkészítéséhez használt módszerek, eredmények, konklúzió

{\bf Kulcsszavak:} a dolgozat tartalmára specifikusan jellemző 4-6 szó, egymástól vesszővel elválasztva
\end{abstract}



\newpage


\pagebreak

\tableofcontents
\pagebreak
%\listoffigures
%\pagebreak








\chapter{Bevezetés}
\pagenumbering{arabic}

\section{Motiváció}

Az alkalmazás ötlete még gimnazista koromban született meg. Az osztálytársaimmal gyakran jártunk össze focizni, ám ezeket az alkalmakat mindig komoly kihívás volt megszervezni. Az legtöbb alkalom azért maradt el, mert nem sikerült olyan időpontot találni, amelyre legalább 8 ember biztosan el tudott jönni. A szavazások nehezen folytak le, rendszerint a messenger-en küldött 'foci péntek délután?', 'foci szombat délelőtt?' stb. üzenetekre adott reakciók száma alapján dőlt el a focizás időpontja. Az alkalmazásom az ehhez hasonló események szervezését könnyíti meg, ahol a legnagyobb kihívás az ideális időpont megtalálása, hiszen a legfontosabb, hogy az minél több emnbernek feleljen meg.

\chapter{Fő funkciók bemutatása}

\section{A felhasználók kezelése}

Az alkalmazásban a felhasználók kezelése nem a legfontosabb feladat, számos, hasonló alkalmazásban gyakori funkciókat, mint a felhasználói profil szerkesztése, vagy a profil törlése, nem valósítottam meg. A felhasználók autentikációja és autorizációja azonban fontos feladat.

	\subsection{Regisztráció}

A felhasználó regisztrálhat egy egyedi felhasználónévvel, egyedi email-címmel, és a legalább 8 karakter hosszú jelszavának kétszer történő megadásával. Amennyiben a megadott névvel vagy email-címmel már foglalt, a rendszer értesíti erről a felhasználót.

	\subsection{Bejelentkezés, kijelentkezés}

A helyes felhasználónév és jelszó megadásával a létrejön egy session, ami 4 órán keresztül biztosít hozzáférést az alkalmazáshoz a felhasználó számára. A session lejárta után az alkalmazás automatikusan kijelentkezteti a felhasználót.

	\subsection{Autorizáció}

Az események adataihoz csak a szervező és a meghívottak férhetnek hozzá. Az eseményeket és az ezekhez tartozó naptárakat csak a szervezők szerkeszthetik.

\section{Események kezelése}

	\subsection{Létrehozás}

Az eseményeket a nevük és egy rövid leírás megadásával lehet létrehozni. Naptár hozzáadása opcionális, ez később is megadható, a részleteiről részletesebben lejjeb írtam.  Az esemény létrehozásakor a szervező automatikusan a meghívottak közé is bekerül.

	\subsection{Csatlakozás}

A szervező és a meghívottak számára látható az esemény meghívó-kódja. Ők ezt a kódot továbbíthatják másoknak, akik ezt a kódot használva a meghívottak közé kerülnek.

	\subsection{Extra mezők}

A szervező extra mezőket adhat az eseményhez. Ezekhez egy cím és a mező lehetséges értékei tartoznak. A mező aktuális értékét beállíthatja a szervező, vagy szavazásra is bocsájthatja azt. Emellett a szervező azt is beállíthatja, hogy a meghívottak vehetnek-e fel új lehetséges értékeket az adott mezőhöz.

	\subsection{Eseménysémák használata}

Egy esemény résztvevője jogosult arra, hogy az eseményből eseménysémát készítsen. A séma tartalmazza az eseményhez rendelt extra mezőket azok tulajdonságaival és lehetséges értékeivel együtt, és alkalmas arra, hogy a használatával új eseményt lehessen létrehozni, amely extra mezői ugyanezekkel a tulajdonságokkal rendelkeznek.

	\subsection{Esemény adatainak véglegesítése}

Egy esemény szervezője véglegesítheti egy esemény adatait (ebbe az esemény időpontja és az extra mezők értékei tartoznak bele).  Ezután az esemény adatai nem módosíthatóak, a meghívottak pedig értesítést kapnak az esemény véglegesítéséről. A művelet visszavonható, ekkor újra módosíthatóvá válnak az adatok, a meghívottak pedig erről is értesítést kapnak.

\section{Naptárak kezelése}

A naptárfelület és a hozzá tartozó funkciók az alkalmazás legfontosabb részét alkotják, hiszen ennek a feladata, hogy segíse az esemény szervezőjét az ideális időpont kiválasztásában. (((ábra a naptárfelületről)))

	\subsection{Létrehozás}

Naptár hozzáadása az időintervallum (legfeljebb 60 nap) és az időzóna megadásával történik. Az intervallum kezdő időpontja nem lehet a múltban, és az intervallum kezdete és vége nem lehet ugyanaz az időpont.

	\subsection{Szerkesztés}

Az esemény szervezője szűkítheti a választható időpontok körét. Az órákat és napokat letilthatja egyenként és naponta, illetve hetente ismétlődő jelleggel is. A szervező ezeket a műveleteket bármikor visszavonhatja.

	\subsection{Vélemény megadása}

Az események résztvevői (ebbe az esemény szervezője is beletartozik) minden elérhető időpontról véleményt formálhatnak. Egy időpontról megadható, hogy megfelelő, elfogadható, vagy nem megfelelő. Vélemény megadásához órákat vagy egész napokat lehet kijelölni. A vélemény rögzítése visszavonható művelet.

	\subsection{Statisztikák megtekintése}

Az események résztvevői minden időpont esetében megtekinthetik, hogy azokhoz mely felhasználók milyen véleményt rögzítettek. Az esemény szervezője átfogóbb statisztikákat is lekérhet. (((ide ábrák kellenek)))

	\subsection{Időzónák kezelése}

Az időzóna megadása azért fontos, mert a  kiválasztható időpontok egész órák, amikből az óraátállítások esetén nem 24 van. A óraátállítások pedig különbözhetnek időzónánként. Fontos, hogy a felhasználók ne tudjanak olyan órákat kijelölni, amik nem léteznek, hiszen ez megtévesztő, és az esetleges plusz órát is jelölni kell.

\chapter{Felhasznált technológiák}

\section{Spring Boot}

A Spring Framework egy Java üzleti alkalmazások fejlesztését segítő keretrendszer. Legfontosabb funkciói közé tartozik a függőség befecskendezés és a Model-View-Controller modell (MVC) támogatása.

A backend alkalmazásomat a Spring Boot\cite{Springwebsite} használatával készítettem el. Ennek segítségével gyorsabban és egyszerűbben tudom elkezdeni a Spring Frameworkre épülő alkalmazásom fejlesztését, mivel a Spring Boot projektek rendelkeznek alapértelmezett konfigurációs beállításokkal, nekem ezeket csak akkor kell átírnom, ha valahol az alapértelmezettől eltérő viselkedést akarok elérni. A fejlesztést InteliJ IDEA (Community Edition)\cite{IDEAwebsite} környezetben végeztem.

	\subsection{Jakarta Persistence API Hibernate ORM-el}

A Hibernate\cite{Hibernatewebsite} segítségével végeztem objektum-relációs leképezéseket a backend alkalmazásomban, ezt azonban a Java Persistence API-n (JPA)\cite{JPAwebsite} keresztül használtam. A JPA egy interfészt szolgáltat, amely segítségével a Java kódban kezelhetem a relációs adatbázisomban (esetemben a MariaDB szerveremen) tárolt adatokat. A JPA-val emellett saját natív query-ket is írtam, ahol az adatokat egyéni módon akartam kezelni.

	\subsection{H2 In-memory DB}

A H2\cite{H2website} memórián belüli adatbázis megvalósítását az integrációs tesztjeimhez használtam. Mivel ez az adatbázis minden futtatás esetében újra inicializálódik, fejlesztés közben egyszerűbb a tesztjeimet futtatnom, hiszen nem kell minden, a leképezendő objektumok kapcsolatait érintő változás esetén a megfelelő strukturális változtatásokat véghezvinnem az adatbázisban. Emellett általánosságban egyszerűbben kezelhető, hiszen nincs szükségem adatbázisszerverre.

\section{MariaDB}

A backend alkalmazás éles futtatása során egy MariaDB\cite{Mariawebsite} adatbázisszerverre kapcsolódik. A MariaDB egy nyílt forráskódú, SQL alapú relációs adatbázis-kezelő rendszer (RDBMS). Más hasonló adatbázisszerverek közül azért erre esett a választásom, mert a tanulmányaim során ezt használtam a legtöbbet.

\section{Angular}

Az Angular\cite{Angularwebsite} egy Google által fejlesztett, nyílt forráskódú, TypeScript alapú keretrendszer webalkalmazások fejlesztésére. Az applikációm frontend részét ezzel valósítottam meg. A választásom azért erre esett, mert a hozzá hasonló keretrenszerek közül ezt ismerem a legjobban, és úgy ítéltem meg, hogy alkalmas modern, reszponzív felhasználói felületek létrehozására. A fejlesztést Visual Studio Code\cite{VSCwebsite} környezetben végeztem.

	\subsection{Angular Material}

A frontenden nagy számban használtam az Angular Material\cite{Materialwebsite} könyvtár komponenseit. Az Angular Material a Google hivatalos UI komponenskönyvtára, számos termékükben használják.

	\subsection{RxJs}

Az RxJs\cite{Rxjswebsite} könyvtár aszinkron műveletek kezelését segítő függvényeket és típusokat tartalmaz. A frontendemen könyvtárban található Observable típust használtam az aszinkron API lekérdezések megvalósításához, valamint a Subject típust használtam azokban az esetekben, amikor gyerek komponensben kellett szülő komponensben bekövetkező eseményre reagálni.

\section{git}

A git\cite{Gitwebsite} verziókövető rendszert használtam a teljes fejlesztési folyamat során. Hogy a konzulensem is követhesse a projekt alakulását, létrehoztam egy nyilvános Github\cite{GitHubwebsite} repository-t, és oda sűrűn pusholtam a local repository commit-jait.


\chapter{Az API fejlesztése}

\section{A model réteg}

A model osztályaim egyszerű POJO-k (Plain Old Java Object). Az osztályokban sűrűn használtam a JPA objektum relációs leképzésekhez szükséges annotációit valamint az általam szerializáláshoz használt Jackson ObjectMapper működését segítő annotációkat. Az alkalmazás további fejlesztése során gyakran használtam a Set interfészt, ezért a model osztályokban felülírtam az equals() és hashCode() metódusokat. Ezek mellett copy konstruktorokat is létrehoztam, hogy lehetőségem legyen az osztályok példányaiknak egyszerű másolására.

\section{A repository réteg}

Minden model osztályhoz létrehoztam egy repository interfészt, amelyeket a JPARepository interfésztől származtattam. A JPARepositoryban már az alapvető CRUD műveletek meg vannak valósítva, én azonban néhány helyen kiegészítettem ezeket új műveletekkel (például az eseményekre nem csupán az ID-jük, hanem a hozzájuk rendelt meghívó kód alapján is lehet keresni az adatbázisban).

\section{A service réteg}

A service komponenseket nem az általuk használt repository-k, hanem a funkcióik szerint különítettem el, így egy service több repository-val is rendelkezhet. A service-ek között tartalmazó kapcsolat is előfordul, pédául a naptárakkal kapcsolatos műveleteket végző CalendarService metódusai kizárólag az eseményeket kezelő EventService-ből hívódnak meg. A service osztályokat @Transactional annotációval láttam el, így az összes service metóduson keresztül történő művelet tranzakcióban folyik.

\subsection{AuthService}

ezt még később megírom ha elrendeztem a jwt-t

\subsection{EventService}

Az EventService-ben történnek az események kezelésével kapcsolatos műveletek, a naptár kezelésének kivételével. Kihívások az írása során:

Az események résztvevőinek jogosultsága van abból eseménysémát készíteni. Ekkor az EventService az esemény összes extra mezőjéből és azoknak a lehetséges értékeiből másolatot készít, és ezeket egyetlen kollekcióba gyűjti össze, majd JSON objektumként tárolom el az eseményséma (EventBlueprint) adatbázistáblában egy generált ID-vel és egy felhasználó által megadott kulcsszóval együtt. A séma felhasználható új események létrehozásakor, ekkor a JSON objektumot deszerializálom, az így elállt extra mezőket a lehetséges értékeivel elmentem az adatbázisba, majd azokat az új eseményhez rendelem.

\subsection{CalendarService}

A naptárak kezelése a CalendarService-en keresztül történik. Kihívások az írása során:

Az óraátállítások kezelése.

Az legjobb időpontok megtalálása az egyik legfontosabb funkciója az alkalmazásnak. Ez a getBestTimeIntervals függvényen keresztül történik, amely négy paramétert vár: a naptárat, a résztvevők minimális számát, az időpontok minimális hosszát, és az elfogadott felhasználói véleménytípusok listáját. A függvény minden órához kiszámítja, hogy milyen hosszú az az ettől az órától kezdődő időszak, amely eleget tesz a paraméterekben megadott minimális hossznak és minimális résztvevőszámnak. Egy ilyen időszak esetében az számít részvevőnek, aki az az összes órára a paraméterben megadott véleménytípus egyikét választotta.

\subsection{MailService}

A felhasználóknak küldött rendszeren belüli üzenetek kezelését végzi. Kihívások az írása során:

Formázott üzenet összeállítása.

\section{Controller réteg}

A controller osztályok szintén funkciók szerint különülnek el, ezért mindegyik tartalmaz hivatkozást a releváns service komponensérere, valamint az AuthService-re, amely a védett végpontok esetében végzi el a felhasználók autorizációját. Minden controller osztályhoz egy útvonal , a REST végpontokat megvalósító metódusaihoz pedig egy-egy alútvonal tartozik.

\section{Kivételkezelés}

Külön kivételosztályokat hoztam létre az események, felhasználók, naptárak kezelése, illetve felhasználók autorizációja során keletkező kivételeknek. A speciálisabb kivételosztályokat ezekből az ősosztályokból öröklődtettem. A controllerek működése során keletkező, el nem kapott kivételek részére létrehoztam egy ControllerAdvice interfészt implementáló globális kivételkezelő osztályt. Ebben megadtam, hogy a keletkezett kivétel függvényében a visszaküldendő válasz milyen üzenetettel és státuszkóddal rendelkezzen.

\section{Tesztelés}

Minden service és controller komponenshez saját tesztosztályt hoztam létre, amelyeket az absztrakt EowaIntegrationTest osztályomból származtattam.  A tesztekhez egy properties fájlt is létrehoztam, ebben megadtam, hogy a tesztek ne a MariaDB adatbázisomat, hanem egy memórián belüli H2 adatbázist használjanak. A service-ekhez tartozó tesztek írása során törekedtem a teljes tesztlefedettségre, a controller-ekhez tartozó tesztek esetében csak annyi tesztet írtam, amennyiből megállapítható, hogy a szerializálás, a deszerializálás, és a kivételek kezelése megfelelő módon történik. A controllereket MockMvc használatával teszteltem. A teszteseteket az "3 A" (Arrange, Act, Assert) szabály szerint készítettem el, azaz először elkészítettem a tesztesethez szükséges objektumokat, ezután elvégetzem a vizsgálandó műveletet, majd ellenőrzöm, hogy az elvárt eredmény sikerült-e elérni.

\newpage
{\Huge \bf Példa tesztesetre}
\begin{lstlisting}

@Test
    public void shouldSelectOptionByMostVotes() throws Exception{
        User owner = new User("felh","asznalo1","email@gmail.com");
        User savedOwner = userService.saveUser(owner);
        User user = new User("felh2","asznalo1","email2@gmail.com");
        User savedUser = userService.saveUser(user);
        Event event = new Event(savedOwner,"kertiparti", Set.of(user),"");

        SelectionField selectionField = new SelectionField("mezo",false,true, Set.of(new Option("ertek"),new Option("ertek2")));
        event.setSelectionFields(Set.of(selectionField));
        Event savedEvent = eventService.saveEvent(event);

        long fieldid = eventService.getEventById(savedEvent.getId()).getSelectionFields().stream()
					.findFirst().get().getId();
        long firstOptionId = eventService.getSelectionFieldById(fieldid).getOptions().stream()
					.filter((o)->o.getValue().equals("ertek"))
					.findFirst().get().getId();
        long secondOptionId = eventService.getSelectionFieldById(fieldid).getOptions().stream()
					.filter((o)->o.getValue().equals("ertek2"))
					.findFirst().get().getId();

        eventService.addVote(firstOptionId,fieldid,user);
        eventService.addVote(secondOptionId,fieldid,user);
        eventService.addVote(secondOptionId,fieldid,owner);

        Assertions.assertFalse(eventService.getOptionById(firstOptionId).isSelected());
        Assertions.assertTrue(eventService.getOptionById(secondOptionId).isSelected());
    }

\end{lstlisting}


\section{Védelem}

\subsection{CORS}

\subsection{Json Web Token}

\chapter{A frontend fejlesztése}

\section{Service réteg}

\section{Fő komponensek}

\subsection{Dialógusablak}

\subsection{Naptárfelület}

\section{Routing}

	\subsection{Auth Guard-ok}

\section{UX}

	\subsection{Canvas Angularban}

\section{Aszinkron programozási megoldások}

\chapter{Továbbfejlesztési lehetőségek}

\chapter{Összefoglalás az eredményekről}
\section{Táblázatok, képletek, egyéb értéssegítők}

Tartalmazhat táblázatokat, melyekre hivatkozni kell a szövegben, például \ref{table:2}. táblázat. A táblázatot középre kell rendezni és a szövegben lévő hivatkozás közelében kell elhelyezni.

\begin{table}[h!]
\centering
\caption{A táblázat címe a táblázat fölé kerül.}
\label{table:2}
\vspace{.2 cm}
\begin{tabular}{||c c c c||} 
 \hline
 Col1 & Col2 & Col2 & Col3 \\ [0.5ex] 
 \hline\hline
  4 & 545 & 18744 & 7560 \\
 5 & 88 & 788 & 6344 \\ [1ex] 
 \hline
\end{tabular}
\end{table}




Tartalmazhat ábrákat. Ezeket középre kell rendezni és hivatkozni kell rájuk a szövegben (lásd \ref{fig:korokuj}). Ha az Irodalmi áttekintés fejezet tartalmazott ábrá(ka)t, akkor a számozás ebben a fejezetben nem újra kezdődik, hanem folytatódik.

Egész oldalas ábrák mellékletben legyenek elhelyezve!

Használjuk bátran a \LaTeX  brilliáns egyenletszerkesztő rendszerét!

A szövegközi $x^2$ képletetket nem, de a kiemelt formulákat általában számozzuk:

 \begin{equation}\label{circle-area}
\mathrm{Var} (A(K_n^r)))\ll n^{-2},
\end{equation}

kivéve a hosszabb számolásokat

\begin{align}
E (& F_n(x_{n+1})^2) = \frac 1{A(K)^{n+1}}\int_K\int_{K^n} \left (\sum_I \mathbf I (F_I\in\mathcal F_{n}(x_{n+1}))\right )^2 d X_n d x_{n+1}\nonumber\\
& = \frac 1{A(K)^{n+1}} \int_K\int_{K^n} \left (\sum_I \mathbb I (F_I\in\mathcal F_{n}(x_{n+1}))\right ) \nonumber \\
& \quad \quad \times \left (\sum_J \mathbf I (F_J\in\mathcal F_{n}(x_{n+1}))\right ) d X_n d x_{n+1}\nonumber\\
&\leq \frac 1{A(K)^{n+1}}\sum_I\sum_J \int_K\int_{K^n} \mathbf I (F_I\in\mathcal F_{n}(x_{n+1}))
\mathbf I (F_J\in\mathcal F_{n}(x_{n+1}))\nonumber\\
&\quad\quad\times\mathbf I(d_H(K,K_n)\leq\varepsilon_K) d X_n d x_{n+1}
+O((1-c_K)^n)\label{ineq1}
%\label{Fn-first} & \ll \frac 1{A(K)^{n+1}} \sum_I\sum_J \int_K\cdots \int_K \indi (F_I\in\F_{n}(x_{n+1}))
%\indi (F_J\in\F_{n}(x_{n+1}))\\ %\notag\\
%&\quad\quad\times\indi(d_H(K,K_n)\leq\varepsilon_K) \d X_n \d x_{n+1} %\textcolor{red}{\sout{+O((1-c_K)^n)}}
%\notag
\end{align}
A képletben használt mennyiségek legyenek megadva az első használatuknál.
\chapter{Összefoglalás}

(új oldalon kezdve)

A dolgozat eredményeinek összefoglalása, következtetések levonása.

Az összefoglalásban egyértelműen jelezve legyen a hallgató saját szerepe/eredményei.

\newpage

\bibliographystyle{alphadin}
\bibliography{mate_koncz} 

\newpage
{\Huge \bf Köszönetnyilvánítás}

 \addcontentsline{toc}{chapter}{Köszönetnyilvánítás}

\vspace{2 cm}

(nem kötelező elem), (új oldalon kezdve) 

Ebben a fejezetben lehet köszönetet mondani mindazoknak, akik segítették a dolgozat elkészülését. Itt lehet megemlíteni továbbá a munkát támogató pályázatokat, ösztöndíjakat, stb.

\newpage
{\Huge \bf Nyilatkozat}

 \addcontentsline{toc}{chapter}{Nyilatkozat}

\vspace{2 cm}

{\it A szöveg kötött, kérjük ezt használni!}

Alulírott, Végzős Edömér, xxxx szakos hallgató, kijelentem, hogy a szakdolgozatban ismertetettek saját munkám eredményei, és minden felhasznált, nem saját munkából származó eredmény esetén hivatkozással jelöltem annak forrását. 


\begin{flushleft}
\vspace*{1cm}
Szeged, \today
\end{flushleft}

\begin{flushright}
 \vspace*{1cm}
 \makebox[7cm]{\rule{6cm}{.4pt}}\\
 \makebox[7cm]{\emph{Végzős Edömér}}
\end{flushright}

\pagebreak

\newpage
{\Huge \bf Mellékletek}

 \addcontentsline{toc}{chapter}{Mellékletek}

\vspace{2 cm}

(nem kötelező elem, a dolgozat oldalszámaiba nem tartozik bele.), (új oldalon kezdve)

Ebben a fejezetben lehet elhelyezni a nagyobb táblázatokat, ábrákat, adathalmazokat.


\end{document}



